package per.frank.dp;

/**
 *
 * 设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。
 * 设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。
 * 这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。
 *
 * 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。
 * 使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。
 * 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，
 * 如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，
 * 每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。
 *
 * 一、根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，
 * 总共有 23 种设计模式。
 * 这些模式可以分为三大类：
 * 1. 创建型模式（Creational Patterns）、
 * 2. 结构型模式（Structural Patterns）、
 * 3. 行为型模式（Behavioral Patterns）。
 * 当然，我们还会讨论另一类设计模式：J2EE 设计模式。
 *
 *
 * 二、设计模式的六大原则
 * 总原则：开闭原则 OCP（Open Close Principle）
 * 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。
 * 所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。
 *
 * 1、单一职责原则 SRP （Single responsibility principle）
 * 定义:  应该有且仅有一个原因引起类的变更。
 * 优点：
 *        1. 类的复杂性降低，实现什么职责都有清晰明确的定义；
 *        2. 可读性提高，复杂性减低，可读性当然提高；
 *        3. 可维护性提高，可读性提高，可维护性当然提高；
 *        4. 变更引起的风险减低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的类有影响，对其他接口无影响，这对系统的扩展性、维护性都有非常大的帮助。
 * 注意： 单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可度量的，因项目而异，因环境而异。
 * 建议： 接口<font color='red'>一定</font>要做到单一职责，类的设计尽量做到只有一个原因引起变化。
 *
 * 2、里氏替换原则 LSP （Liskov Substitution Principle）
 * 主要就是要合理的使用继承，与如何正确的使用继承的方法原则
 * 继承的优点：
 *        1. 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性；
 *        2. 提高代码的重用性；
 *        3. 子类可以形似父类，但又异于父类；
 *        4. 提高代码的可扩展性；
 *        5. 提高产品或项目的开放性。
 * 继承的缺点：
 *        1. 继承是侵入性的，只要继承就必须拥有父类的所有属性和方法；
 *        2. 降低代码的灵活性，子类必须拥有父类的属性和方法，让子类增加了约束；
 *        3. 增强了耦合性，当父类的常量、变量和方法被修改时，必须考虑子类的修改。
 *
 * 定义:  所有引用基类的地方必须能透明地使用其子类的对象。
 *        通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。
 *        但是，反过来就不行了，有子类出现的地方，父类未必就能适应。
 * 含义:
 *        1. 子类必须完全实现父类的方法。
 *           如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中发生了“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。
 *        2. 子类可以有自己的个性
 *        3. 覆盖或实现父类的方法时输入参数可以被放大
 *        4. 覆盖或实现父类的方法时输出结果可以被缩小
 * 目的:
 *        采用里氏替换原则的目的就是增强程序的健壮性，版本升级是也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。
 *        在实际项目中，每个子类对应不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑。
 *
 * 3、依赖倒转原则 DIP （Dependence Inversion Principle）
 * 这个是开闭原则的基础
 * 原始定义:
 *        1. 高层模块不应该依赖底层模块，两者都应该依赖其抽象；
 *        2. 抽象不应该依赖细节；
 *        3. 细节应该依赖抽象。
 *
 * 原始定义:
 *        1. 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或者抽象类产生的；
 *        2. 接口或抽象类不依赖于实现类；
 *        3. 实现类依赖接口或抽象类。
 *
 * 4、接口隔离原则 ISP （Interface Segregation Principle）
 * 定义:
 *        1. 客户端不应该依赖它不需要的接口
 *        2. 类间的依赖关系应该建立在最小的接口上
 * 含义：
 *        1. 接口要尽量小
 *           这是接口隔离原则的核心定义，不出现臃肿的接口（Fat Interface），但是“小”是有限度的，首先就是不能违反单一职责原则。
 *           根据接口隔离原则拆分接口时，首先必须满足单一职责原则。
 *        2. 接口要高内聚
 *           高内聚就是要提高接口、类、模块的处理能力，减少对外的交互。
 *           具体到接口隔离原则就是，要求在接口中尽量少公布public方法，接口是对外的承诺，承诺地越少对系统开发越有利，变更的风险也就越少，同时也有利于降低成本。
 *        3. 定制服务
 *           定制服务就是单独为一个个体提供优良的服务。
 *           接口设计是有限度的
 *           接口的设计粒度越小，系统越灵活，这是不争的事实。
 *           但是，灵活的同时也带来了结构的复杂化，开发难度增加，可维护性降低，这不是一个项目或产品所期望看到的，所以接口设计一定要注意适度，
 *           这个度只能根据经验和常识判断，没有一个固化或可测量的标准。
 *
 * 5、迪米特法则（最少知道原则）LoD LKP （Demeter Principle, Least Knowledge Principle）
 * 定义：
 *        迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least Knowledge Principle，LKP）。
 *        一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，
 *        你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的public方法，我就调用这么多，其他的一概不关心。
 *
 * 6、合成复用原则 CARP（Composite Reuse Principle）
 * 定义：
 *        要尽量使用合成和聚合，尽量不要使用继承
 * 释义
 *     第一，继承复用破坏包装，它把父类的实现细节直接暴露给了子类，这违背了信息隐藏的原则；
 *     第二：如果父类发生了改变，那么子类也要发生相应的改变，这就直接导致了类与类之间的高耦合，不利于类的扩展、复用、维护等，也带来了系统僵硬和脆弱的设计。而用合成和聚合的时候新对象和已有对象的交互往往是通过接口或者抽象类进行的，就可以很好的避免上面的不足，而且这也可以让每一个新的类专注于实现自己的任务，符合单一职责原则。
 *
 *
 * 参考: https://www.cnblogs.com/muzongyan/category/256115.html
 *       https://blog.csdn.net/zlts000/article/details/26749723
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 * 1.创建型模式: 类的高效，安全的创建方式。
 * 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。
 * 工厂模式（Factory Pattern）
 * 抽象工厂模式（Abstract Factory Pattern）
 * 单例模式（Singleton Pattern）
 * 建造者模式（Builder Pattern）
 * 原型模式（Prototype Pattern）
 * <p>
 * 2.结构型模式: 组合方法与接口，生成高可用的新方法，做好隔离
 * 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。
 * 适配器模式（Adapter Pattern）
 * 桥接模式（Bridge Pattern）
 * 过滤器模式（Filter、Criteria Pattern）
 * 组合模式（Composite Pattern）
 * 装饰器模式（Decorator Pattern）
 * 外观模式（Facade Pattern）
 * 享元模式（Flyweight Pattern）
 * 代理模式（Proxy Pattern）
 * <p>
 * 3.行为型模式: 通信
 * 这些设计模式特别关注对象之间的通信。
 * 责任链模式（Chain of Responsibility Pattern）
 * 命令模式（Command Pattern）
 * 解释器模式（Interpreter Pattern）
 * 迭代器模式（Iterator Pattern）
 * 中介者模式（Mediator Pattern）
 * 备忘录模式（Memento Pattern）
 * 观察者模式（Observer Pattern）
 * 状态模式（State Pattern）
 * 空对象模式（Null Object Pattern）
 * 策略模式（Strategy Pattern）
 * 模板模式（Template Pattern）
 * 访问者模式（Visitor Pattern）
 * <p>
 * 4.J2EE 模式: 新时代出现的新模式
 * 这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。
 * MVC 模式（MVC Pattern）
 * 业务代表模式（Business Delegate Pattern）
 * 组合实体模式（Composite Entity Pattern）
 * 数据访问对象模式（Data Access Object Pattern）
 * 前端控制器模式（Front Controller Pattern）
 * 拦截过滤器模式（Intercepting Filter Pattern）
 * 服务定位器模式（Service Locator Pattern）
 * 传输对象模式（Transfer Object Pattern）
 */